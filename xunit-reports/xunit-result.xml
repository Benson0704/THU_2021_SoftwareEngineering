<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite errors="0" failures="4" hostname="MacBookPro0704.local" name="pytest" skipped="0" tests="4" time="23.004" timestamp="2021-03-25T17:13:05.017114"><testcase classname="tests.login_test.TestLogin" file="tests/login_test.py" line="82" name="test_get_registered_user" time="5.022"><failure message="django.db.utils.OperationalError: (2003, &quot;Can&apos;t connect to MySQL server on &apos;mysql.FullHouse.secoder.local&apos; ([Errno 8] nodename nor servname provided, or not known)&quot;)">self = &lt;pymysql.connections.Connection object at 0x7fb33d34d940&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG:
                        print(&quot;connected using unix_socket&quot;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&quot;source_address&quot;] = (self.bind_address, 0)
                    while True:
                        try:
&gt;                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

../../../opt/anaconda3/lib/python3.8/site-packages/pymysql/connections.py:613: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;mysql.FullHouse.secoder.local&apos;, 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        err = None
&gt;       for res in getaddrinfo(host, port, 0, SOCK_STREAM):

../../../opt/anaconda3/lib/python3.8/socket.py:787: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = &apos;mysql.FullHouse.secoder.local&apos;, port = 3306, family = 0, type = &lt;SocketKind.SOCK_STREAM: 1&gt;, proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        &quot;&quot;&quot;Resolve host and port into list of address info entries.
    
        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as &apos;http&apos;, a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.
    
        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        &quot;&quot;&quot;
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
&gt;       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno 8] nodename nor servname provided, or not known

../../../opt/anaconda3/lib/python3.8/socket.py:918: gaierror

During handling of the above exception, another exception occurred:

self = &lt;django.db.backends.mysql.base.DatabaseWrapper object at 0x7fb33d1c1070&gt;

    @async_unsafe
    def ensure_connection(self):
        &quot;&quot;&quot;Guarantee that a connection to the database is established.&quot;&quot;&quot;
        if self.connection is None:
            with self.wrap_database_errors:
&gt;               self.connect()

../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/base/base.py:220: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (&lt;django.db.backends.mysql.base.DatabaseWrapper object at 0x7fb33d1c1070&gt;,), kwargs = {}
event_loop = &lt;_UnixSelectorEventLoop running=False closed=False debug=False&gt;

    @functools.wraps(func)
    def inner(*args, **kwargs):
        if not os.environ.get(&apos;DJANGO_ALLOW_ASYNC_UNSAFE&apos;):
            # Detect a running event loop in this thread.
            try:
                event_loop = asyncio.get_event_loop()
            except RuntimeError:
                pass
            else:
                if event_loop.is_running():
                    raise SynchronousOnlyOperation(message)
        # Pass onwards.
&gt;       return func(*args, **kwargs)

../../../opt/anaconda3/lib/python3.8/site-packages/django/utils/asyncio.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.db.backends.mysql.base.DatabaseWrapper object at 0x7fb33d1c1070&gt;

    @async_unsafe
    def connect(self):
        &quot;&quot;&quot;Connect to the database. Assume that the connection is closed.&quot;&quot;&quot;
        # Check for invalid configurations.
        self.check_settings()
        # In case the previous connection was closed while in an atomic block
        self.in_atomic_block = False
        self.savepoint_ids = []
        self.needs_rollback = False
        # Reset parameters defining when to close the connection
        max_age = self.settings_dict[&apos;CONN_MAX_AGE&apos;]
        self.close_at = None if max_age is None else time.monotonic() + max_age
        self.closed_in_transaction = False
        self.errors_occurred = False
        # Establish the connection
        conn_params = self.get_connection_params()
&gt;       self.connection = self.get_new_connection(conn_params)

../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/base/base.py:197: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (&lt;django.db.backends.mysql.base.DatabaseWrapper object at 0x7fb33d1c1070&gt;, {&apos;charset&apos;: &apos;utf8&apos;, &apos;client_flag&apos;: 2, &apos;conv... escape_float at 0x7fb33d1fc1f0&gt;, &lt;class &apos;str&apos;&gt;: &lt;function escape_str at 0x7fb33d1fc430&gt;, ...}, &apos;db&apos;: &apos;kuaishou&apos;, ...})
kwargs = {}, event_loop = &lt;_UnixSelectorEventLoop running=False closed=False debug=False&gt;

    @functools.wraps(func)
    def inner(*args, **kwargs):
        if not os.environ.get(&apos;DJANGO_ALLOW_ASYNC_UNSAFE&apos;):
            # Detect a running event loop in this thread.
            try:
                event_loop = asyncio.get_event_loop()
            except RuntimeError:
                pass
            else:
                if event_loop.is_running():
                    raise SynchronousOnlyOperation(message)
        # Pass onwards.
&gt;       return func(*args, **kwargs)

../../../opt/anaconda3/lib/python3.8/site-packages/django/utils/asyncio.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.db.backends.mysql.base.DatabaseWrapper object at 0x7fb33d1c1070&gt;
conn_params = {&apos;charset&apos;: &apos;utf8&apos;, &apos;client_flag&apos;: 2, &apos;conv&apos;: {&lt;class &apos;bool&apos;&gt;: &lt;function escape_bool at 0x7fb33d1fc0d0&gt;, &lt;class &apos;int&apos;&gt;...n escape_float at 0x7fb33d1fc1f0&gt;, &lt;class &apos;str&apos;&gt;: &lt;function escape_str at 0x7fb33d1fc430&gt;, ...}, &apos;db&apos;: &apos;kuaishou&apos;, ...}

    @async_unsafe
    def get_new_connection(self, conn_params):
&gt;       return Database.connect(**conn_params)

../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/mysql/base.py:233: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pymysql.connections.Connection object at 0x7fb33d34d940&gt;

    def __init__(
        self,
        *,
        user=None,  # The first four arguments is based on DB-API 2.0 recommendation.
        password=&quot;&quot;,
        host=None,
        database=None,
        unix_socket=None,
        port=0,
        charset=&quot;&quot;,
        sql_mode=None,
        read_default_file=None,
        conv=None,
        use_unicode=True,
        client_flag=0,
        cursorclass=Cursor,
        init_command=None,
        connect_timeout=10,
        read_default_group=None,
        autocommit=False,
        local_infile=False,
        max_allowed_packet=16 * 1024 * 1024,
        defer_connect=False,
        auth_plugin_map=None,
        read_timeout=None,
        write_timeout=None,
        bind_address=None,
        binary_prefix=False,
        program_name=None,
        server_public_key=None,
        ssl=None,
        ssl_ca=None,
        ssl_cert=None,
        ssl_disabled=None,
        ssl_key=None,
        ssl_verify_cert=None,
        ssl_verify_identity=None,
        compress=None,  # not supported
        named_pipe=None,  # not supported
        passwd=None,  # deprecated
        db=None,  # deprecated
    ):
        if db is not None and database is None:
            # We will raise warining in 2022 or later.
            # See https://github.com/PyMySQL/PyMySQL/issues/939
            # warnings.warn(&quot;&apos;db&apos; is deprecated, use &apos;database&apos;&quot;, DeprecationWarning, 3)
            database = db
        if passwd is not None and not password:
            # We will raise warining in 2022 or later.
            # See https://github.com/PyMySQL/PyMySQL/issues/939
            # warnings.warn(
            #    &quot;&apos;passwd&apos; is deprecated, use &apos;password&apos;&quot;, DeprecationWarning, 3
            # )
            password = passwd
    
        if compress or named_pipe:
            raise NotImplementedError(
                &quot;compress and named_pipe arguments are not supported&quot;
            )
    
        self._local_infile = bool(local_infile)
        if self._local_infile:
            client_flag |= CLIENT.LOCAL_FILES
    
        if read_default_group and not read_default_file:
            if sys.platform.startswith(&quot;win&quot;):
                read_default_file = &quot;c:\\my.ini&quot;
            else:
                read_default_file = &quot;/etc/my.cnf&quot;
    
        if read_default_file:
            if not read_default_group:
                read_default_group = &quot;client&quot;
    
            cfg = Parser()
            cfg.read(os.path.expanduser(read_default_file))
    
            def _config(key, arg):
                if arg:
                    return arg
                try:
                    return cfg.get(read_default_group, key)
                except Exception:
                    return arg
    
            user = _config(&quot;user&quot;, user)
            password = _config(&quot;password&quot;, password)
            host = _config(&quot;host&quot;, host)
            database = _config(&quot;database&quot;, database)
            unix_socket = _config(&quot;socket&quot;, unix_socket)
            port = int(_config(&quot;port&quot;, port))
            bind_address = _config(&quot;bind-address&quot;, bind_address)
            charset = _config(&quot;default-character-set&quot;, charset)
            if not ssl:
                ssl = {}
            if isinstance(ssl, dict):
                for key in [&quot;ca&quot;, &quot;capath&quot;, &quot;cert&quot;, &quot;key&quot;, &quot;cipher&quot;]:
                    value = _config(&quot;ssl-&quot; + key, ssl.get(key))
                    if value:
                        ssl[key] = value
    
        self.ssl = False
        if not ssl_disabled:
            if ssl_ca or ssl_cert or ssl_key or ssl_verify_cert or ssl_verify_identity:
                ssl = {
                    &quot;ca&quot;: ssl_ca,
                    &quot;check_hostname&quot;: bool(ssl_verify_identity),
                    &quot;verify_mode&quot;: ssl_verify_cert
                    if ssl_verify_cert is not None
                    else False,
                }
                if ssl_cert is not None:
                    ssl[&quot;cert&quot;] = ssl_cert
                if ssl_key is not None:
                    ssl[&quot;key&quot;] = ssl_key
            if ssl:
                if not SSL_ENABLED:
                    raise NotImplementedError(&quot;ssl module not found&quot;)
                self.ssl = True
                client_flag |= CLIENT.SSL
                self.ctx = self._create_ssl_ctx(ssl)
    
        self.host = host or &quot;localhost&quot;
        self.port = port or 3306
        if type(self.port) is not int:
            raise ValueError(&quot;port should be of type int&quot;)
        self.user = user or DEFAULT_USER
        self.password = password or b&quot;&quot;
        if isinstance(self.password, str):
            self.password = self.password.encode(&quot;latin1&quot;)
        self.db = database
        self.unix_socket = unix_socket
        self.bind_address = bind_address
        if not (0 &lt; connect_timeout &lt;= 31536000):
            raise ValueError(&quot;connect_timeout should be &gt;0 and &lt;=31536000&quot;)
        self.connect_timeout = connect_timeout or None
        if read_timeout is not None and read_timeout &lt;= 0:
            raise ValueError(&quot;read_timeout should be &gt; 0&quot;)
        self._read_timeout = read_timeout
        if write_timeout is not None and write_timeout &lt;= 0:
            raise ValueError(&quot;write_timeout should be &gt; 0&quot;)
        self._write_timeout = write_timeout
    
        self.charset = charset or DEFAULT_CHARSET
        self.use_unicode = use_unicode
    
        self.encoding = charset_by_name(self.charset).encoding
    
        client_flag |= CLIENT.CAPABILITIES
        if self.db:
            client_flag |= CLIENT.CONNECT_WITH_DB
    
        self.client_flag = client_flag
    
        self.cursorclass = cursorclass
    
        self._result = None
        self._affected_rows = 0
        self.host_info = &quot;Not connected&quot;
    
        # specified autocommit mode. None means use server default.
        self.autocommit_mode = autocommit
    
        if conv is None:
            conv = converters.conversions
    
        # Need for MySQLdb compatibility.
        self.encoders = {k: v for (k, v) in conv.items() if type(k) is not int}
        self.decoders = {k: v for (k, v) in conv.items() if type(k) is int}
        self.sql_mode = sql_mode
        self.init_command = init_command
        self.max_allowed_packet = max_allowed_packet
        self._auth_plugin_map = auth_plugin_map or {}
        self._binary_prefix = binary_prefix
        self.server_public_key = server_public_key
    
        self._connect_attrs = {
            &quot;_client_name&quot;: &quot;pymysql&quot;,
            &quot;_pid&quot;: str(os.getpid()),
            &quot;_client_version&quot;: VERSION_STRING,
        }
    
        if program_name:
            self._connect_attrs[&quot;program_name&quot;] = program_name
    
        if defer_connect:
            self._sock = None
        else:
&gt;           self.connect()

../../../opt/anaconda3/lib/python3.8/site-packages/pymysql/connections.py:353: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pymysql.connections.Connection object at 0x7fb33d34d940&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG:
                        print(&quot;connected using unix_socket&quot;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&quot;source_address&quot;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG:
                        print(&quot;connected using socket&quot;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile(&quot;rb&quot;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                    2003, &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (self.host, e)
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
&gt;               raise exc
E               pymysql.err.OperationalError: (2003, &quot;Can&apos;t connect to MySQL server on &apos;mysql.FullHouse.secoder.local&apos; ([Errno 8] nodename nor servname provided, or not known)&quot;)

../../../opt/anaconda3/lib/python3.8/site-packages/pymysql/connections.py:664: OperationalError

The above exception was the direct cause of the following exception:

self = &lt;tests.login_test.TestLogin testMethod=test_get_registered_user&gt;

    def setUp(self):
&gt;       brisa = User.objects.create(open_id=&quot;todayisagoodday&quot;,
                                    public_count=2,
                                    friend_count=0,
                                    private_count=0,
                                    all_count=2)

tests/login_test.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/manager.py:82: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/query.py:433: in create
    obj.save(force_insert=True, using=self.db)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/base.py:745: in save
    self.save_base(using=using, force_insert=force_insert,
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/base.py:782: in save_base
    updated = self._save_table(
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/base.py:887: in _save_table
    results = self._do_insert(cls._base_manager, using, fields, returning_fields, raw)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/base.py:924: in _do_insert
    return manager._insert(
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/manager.py:82: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/query.py:1204: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/sql/compiler.py:1390: in execute_sql
    with self.connection.cursor() as cursor:
../../../opt/anaconda3/lib/python3.8/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/base/base.py:260: in cursor
    return self._cursor()
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/base/base.py:236: in _cursor
    self.ensure_connection()
../../../opt/anaconda3/lib/python3.8/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/base/base.py:220: in ensure_connection
    self.connect()
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/utils.py:90: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/base/base.py:220: in ensure_connection
    self.connect()
../../../opt/anaconda3/lib/python3.8/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/base/base.py:197: in connect
    self.connection = self.get_new_connection(conn_params)
../../../opt/anaconda3/lib/python3.8/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/mysql/base.py:233: in get_new_connection
    return Database.connect(**conn_params)
../../../opt/anaconda3/lib/python3.8/site-packages/pymysql/connections.py:353: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pymysql.connections.Connection object at 0x7fb33d34d940&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG:
                        print(&quot;connected using unix_socket&quot;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&quot;source_address&quot;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG:
                        print(&quot;connected using socket&quot;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile(&quot;rb&quot;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                    2003, &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (self.host, e)
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
&gt;               raise exc
E               django.db.utils.OperationalError: (2003, &quot;Can&apos;t connect to MySQL server on &apos;mysql.FullHouse.secoder.local&apos; ([Errno 8] nodename nor servname provided, or not known)&quot;)

../../../opt/anaconda3/lib/python3.8/site-packages/pymysql/connections.py:664: OperationalError</failure></testcase><testcase classname="tests.login_test.TestLogin" file="tests/login_test.py" line="50" name="test_initialize_new_user" time="5.003"><failure message="django.db.utils.OperationalError: (2003, &quot;Can&apos;t connect to MySQL server on &apos;mysql.FullHouse.secoder.local&apos; ([Errno 8] nodename nor servname provided, or not known)&quot;)">self = &lt;pymysql.connections.Connection object at 0x7fb33e4c0490&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG:
                        print(&quot;connected using unix_socket&quot;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&quot;source_address&quot;] = (self.bind_address, 0)
                    while True:
                        try:
&gt;                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

../../../opt/anaconda3/lib/python3.8/site-packages/pymysql/connections.py:613: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;mysql.FullHouse.secoder.local&apos;, 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        err = None
&gt;       for res in getaddrinfo(host, port, 0, SOCK_STREAM):

../../../opt/anaconda3/lib/python3.8/socket.py:787: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = &apos;mysql.FullHouse.secoder.local&apos;, port = 3306, family = 0, type = &lt;SocketKind.SOCK_STREAM: 1&gt;, proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        &quot;&quot;&quot;Resolve host and port into list of address info entries.
    
        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as &apos;http&apos;, a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.
    
        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        &quot;&quot;&quot;
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
&gt;       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno 8] nodename nor servname provided, or not known

../../../opt/anaconda3/lib/python3.8/socket.py:918: gaierror

During handling of the above exception, another exception occurred:

self = &lt;django.db.backends.mysql.base.DatabaseWrapper object at 0x7fb33d1c1070&gt;

    @async_unsafe
    def ensure_connection(self):
        &quot;&quot;&quot;Guarantee that a connection to the database is established.&quot;&quot;&quot;
        if self.connection is None:
            with self.wrap_database_errors:
&gt;               self.connect()

../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/base/base.py:220: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (&lt;django.db.backends.mysql.base.DatabaseWrapper object at 0x7fb33d1c1070&gt;,), kwargs = {}
event_loop = &lt;_UnixSelectorEventLoop running=False closed=False debug=False&gt;

    @functools.wraps(func)
    def inner(*args, **kwargs):
        if not os.environ.get(&apos;DJANGO_ALLOW_ASYNC_UNSAFE&apos;):
            # Detect a running event loop in this thread.
            try:
                event_loop = asyncio.get_event_loop()
            except RuntimeError:
                pass
            else:
                if event_loop.is_running():
                    raise SynchronousOnlyOperation(message)
        # Pass onwards.
&gt;       return func(*args, **kwargs)

../../../opt/anaconda3/lib/python3.8/site-packages/django/utils/asyncio.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.db.backends.mysql.base.DatabaseWrapper object at 0x7fb33d1c1070&gt;

    @async_unsafe
    def connect(self):
        &quot;&quot;&quot;Connect to the database. Assume that the connection is closed.&quot;&quot;&quot;
        # Check for invalid configurations.
        self.check_settings()
        # In case the previous connection was closed while in an atomic block
        self.in_atomic_block = False
        self.savepoint_ids = []
        self.needs_rollback = False
        # Reset parameters defining when to close the connection
        max_age = self.settings_dict[&apos;CONN_MAX_AGE&apos;]
        self.close_at = None if max_age is None else time.monotonic() + max_age
        self.closed_in_transaction = False
        self.errors_occurred = False
        # Establish the connection
        conn_params = self.get_connection_params()
&gt;       self.connection = self.get_new_connection(conn_params)

../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/base/base.py:197: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (&lt;django.db.backends.mysql.base.DatabaseWrapper object at 0x7fb33d1c1070&gt;, {&apos;charset&apos;: &apos;utf8&apos;, &apos;client_flag&apos;: 2, &apos;conv... escape_float at 0x7fb33d1fc1f0&gt;, &lt;class &apos;str&apos;&gt;: &lt;function escape_str at 0x7fb33d1fc430&gt;, ...}, &apos;db&apos;: &apos;kuaishou&apos;, ...})
kwargs = {}, event_loop = &lt;_UnixSelectorEventLoop running=False closed=False debug=False&gt;

    @functools.wraps(func)
    def inner(*args, **kwargs):
        if not os.environ.get(&apos;DJANGO_ALLOW_ASYNC_UNSAFE&apos;):
            # Detect a running event loop in this thread.
            try:
                event_loop = asyncio.get_event_loop()
            except RuntimeError:
                pass
            else:
                if event_loop.is_running():
                    raise SynchronousOnlyOperation(message)
        # Pass onwards.
&gt;       return func(*args, **kwargs)

../../../opt/anaconda3/lib/python3.8/site-packages/django/utils/asyncio.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.db.backends.mysql.base.DatabaseWrapper object at 0x7fb33d1c1070&gt;
conn_params = {&apos;charset&apos;: &apos;utf8&apos;, &apos;client_flag&apos;: 2, &apos;conv&apos;: {&lt;class &apos;bool&apos;&gt;: &lt;function escape_bool at 0x7fb33d1fc0d0&gt;, &lt;class &apos;int&apos;&gt;...n escape_float at 0x7fb33d1fc1f0&gt;, &lt;class &apos;str&apos;&gt;: &lt;function escape_str at 0x7fb33d1fc430&gt;, ...}, &apos;db&apos;: &apos;kuaishou&apos;, ...}

    @async_unsafe
    def get_new_connection(self, conn_params):
&gt;       return Database.connect(**conn_params)

../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/mysql/base.py:233: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pymysql.connections.Connection object at 0x7fb33e4c0490&gt;

    def __init__(
        self,
        *,
        user=None,  # The first four arguments is based on DB-API 2.0 recommendation.
        password=&quot;&quot;,
        host=None,
        database=None,
        unix_socket=None,
        port=0,
        charset=&quot;&quot;,
        sql_mode=None,
        read_default_file=None,
        conv=None,
        use_unicode=True,
        client_flag=0,
        cursorclass=Cursor,
        init_command=None,
        connect_timeout=10,
        read_default_group=None,
        autocommit=False,
        local_infile=False,
        max_allowed_packet=16 * 1024 * 1024,
        defer_connect=False,
        auth_plugin_map=None,
        read_timeout=None,
        write_timeout=None,
        bind_address=None,
        binary_prefix=False,
        program_name=None,
        server_public_key=None,
        ssl=None,
        ssl_ca=None,
        ssl_cert=None,
        ssl_disabled=None,
        ssl_key=None,
        ssl_verify_cert=None,
        ssl_verify_identity=None,
        compress=None,  # not supported
        named_pipe=None,  # not supported
        passwd=None,  # deprecated
        db=None,  # deprecated
    ):
        if db is not None and database is None:
            # We will raise warining in 2022 or later.
            # See https://github.com/PyMySQL/PyMySQL/issues/939
            # warnings.warn(&quot;&apos;db&apos; is deprecated, use &apos;database&apos;&quot;, DeprecationWarning, 3)
            database = db
        if passwd is not None and not password:
            # We will raise warining in 2022 or later.
            # See https://github.com/PyMySQL/PyMySQL/issues/939
            # warnings.warn(
            #    &quot;&apos;passwd&apos; is deprecated, use &apos;password&apos;&quot;, DeprecationWarning, 3
            # )
            password = passwd
    
        if compress or named_pipe:
            raise NotImplementedError(
                &quot;compress and named_pipe arguments are not supported&quot;
            )
    
        self._local_infile = bool(local_infile)
        if self._local_infile:
            client_flag |= CLIENT.LOCAL_FILES
    
        if read_default_group and not read_default_file:
            if sys.platform.startswith(&quot;win&quot;):
                read_default_file = &quot;c:\\my.ini&quot;
            else:
                read_default_file = &quot;/etc/my.cnf&quot;
    
        if read_default_file:
            if not read_default_group:
                read_default_group = &quot;client&quot;
    
            cfg = Parser()
            cfg.read(os.path.expanduser(read_default_file))
    
            def _config(key, arg):
                if arg:
                    return arg
                try:
                    return cfg.get(read_default_group, key)
                except Exception:
                    return arg
    
            user = _config(&quot;user&quot;, user)
            password = _config(&quot;password&quot;, password)
            host = _config(&quot;host&quot;, host)
            database = _config(&quot;database&quot;, database)
            unix_socket = _config(&quot;socket&quot;, unix_socket)
            port = int(_config(&quot;port&quot;, port))
            bind_address = _config(&quot;bind-address&quot;, bind_address)
            charset = _config(&quot;default-character-set&quot;, charset)
            if not ssl:
                ssl = {}
            if isinstance(ssl, dict):
                for key in [&quot;ca&quot;, &quot;capath&quot;, &quot;cert&quot;, &quot;key&quot;, &quot;cipher&quot;]:
                    value = _config(&quot;ssl-&quot; + key, ssl.get(key))
                    if value:
                        ssl[key] = value
    
        self.ssl = False
        if not ssl_disabled:
            if ssl_ca or ssl_cert or ssl_key or ssl_verify_cert or ssl_verify_identity:
                ssl = {
                    &quot;ca&quot;: ssl_ca,
                    &quot;check_hostname&quot;: bool(ssl_verify_identity),
                    &quot;verify_mode&quot;: ssl_verify_cert
                    if ssl_verify_cert is not None
                    else False,
                }
                if ssl_cert is not None:
                    ssl[&quot;cert&quot;] = ssl_cert
                if ssl_key is not None:
                    ssl[&quot;key&quot;] = ssl_key
            if ssl:
                if not SSL_ENABLED:
                    raise NotImplementedError(&quot;ssl module not found&quot;)
                self.ssl = True
                client_flag |= CLIENT.SSL
                self.ctx = self._create_ssl_ctx(ssl)
    
        self.host = host or &quot;localhost&quot;
        self.port = port or 3306
        if type(self.port) is not int:
            raise ValueError(&quot;port should be of type int&quot;)
        self.user = user or DEFAULT_USER
        self.password = password or b&quot;&quot;
        if isinstance(self.password, str):
            self.password = self.password.encode(&quot;latin1&quot;)
        self.db = database
        self.unix_socket = unix_socket
        self.bind_address = bind_address
        if not (0 &lt; connect_timeout &lt;= 31536000):
            raise ValueError(&quot;connect_timeout should be &gt;0 and &lt;=31536000&quot;)
        self.connect_timeout = connect_timeout or None
        if read_timeout is not None and read_timeout &lt;= 0:
            raise ValueError(&quot;read_timeout should be &gt; 0&quot;)
        self._read_timeout = read_timeout
        if write_timeout is not None and write_timeout &lt;= 0:
            raise ValueError(&quot;write_timeout should be &gt; 0&quot;)
        self._write_timeout = write_timeout
    
        self.charset = charset or DEFAULT_CHARSET
        self.use_unicode = use_unicode
    
        self.encoding = charset_by_name(self.charset).encoding
    
        client_flag |= CLIENT.CAPABILITIES
        if self.db:
            client_flag |= CLIENT.CONNECT_WITH_DB
    
        self.client_flag = client_flag
    
        self.cursorclass = cursorclass
    
        self._result = None
        self._affected_rows = 0
        self.host_info = &quot;Not connected&quot;
    
        # specified autocommit mode. None means use server default.
        self.autocommit_mode = autocommit
    
        if conv is None:
            conv = converters.conversions
    
        # Need for MySQLdb compatibility.
        self.encoders = {k: v for (k, v) in conv.items() if type(k) is not int}
        self.decoders = {k: v for (k, v) in conv.items() if type(k) is int}
        self.sql_mode = sql_mode
        self.init_command = init_command
        self.max_allowed_packet = max_allowed_packet
        self._auth_plugin_map = auth_plugin_map or {}
        self._binary_prefix = binary_prefix
        self.server_public_key = server_public_key
    
        self._connect_attrs = {
            &quot;_client_name&quot;: &quot;pymysql&quot;,
            &quot;_pid&quot;: str(os.getpid()),
            &quot;_client_version&quot;: VERSION_STRING,
        }
    
        if program_name:
            self._connect_attrs[&quot;program_name&quot;] = program_name
    
        if defer_connect:
            self._sock = None
        else:
&gt;           self.connect()

../../../opt/anaconda3/lib/python3.8/site-packages/pymysql/connections.py:353: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pymysql.connections.Connection object at 0x7fb33e4c0490&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG:
                        print(&quot;connected using unix_socket&quot;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&quot;source_address&quot;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG:
                        print(&quot;connected using socket&quot;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile(&quot;rb&quot;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                    2003, &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (self.host, e)
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
&gt;               raise exc
E               pymysql.err.OperationalError: (2003, &quot;Can&apos;t connect to MySQL server on &apos;mysql.FullHouse.secoder.local&apos; ([Errno 8] nodename nor servname provided, or not known)&quot;)

../../../opt/anaconda3/lib/python3.8/site-packages/pymysql/connections.py:664: OperationalError

The above exception was the direct cause of the following exception:

self = &lt;tests.login_test.TestLogin testMethod=test_initialize_new_user&gt;

    def setUp(self):
&gt;       brisa = User.objects.create(open_id=&quot;todayisagoodday&quot;,
                                    public_count=2,
                                    friend_count=0,
                                    private_count=0,
                                    all_count=2)

tests/login_test.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/manager.py:82: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/query.py:433: in create
    obj.save(force_insert=True, using=self.db)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/base.py:745: in save
    self.save_base(using=using, force_insert=force_insert,
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/base.py:782: in save_base
    updated = self._save_table(
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/base.py:887: in _save_table
    results = self._do_insert(cls._base_manager, using, fields, returning_fields, raw)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/base.py:924: in _do_insert
    return manager._insert(
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/manager.py:82: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/query.py:1204: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/sql/compiler.py:1390: in execute_sql
    with self.connection.cursor() as cursor:
../../../opt/anaconda3/lib/python3.8/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/base/base.py:260: in cursor
    return self._cursor()
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/base/base.py:236: in _cursor
    self.ensure_connection()
../../../opt/anaconda3/lib/python3.8/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/base/base.py:220: in ensure_connection
    self.connect()
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/utils.py:90: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/base/base.py:220: in ensure_connection
    self.connect()
../../../opt/anaconda3/lib/python3.8/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/base/base.py:197: in connect
    self.connection = self.get_new_connection(conn_params)
../../../opt/anaconda3/lib/python3.8/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/mysql/base.py:233: in get_new_connection
    return Database.connect(**conn_params)
../../../opt/anaconda3/lib/python3.8/site-packages/pymysql/connections.py:353: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pymysql.connections.Connection object at 0x7fb33e4c0490&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG:
                        print(&quot;connected using unix_socket&quot;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&quot;source_address&quot;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG:
                        print(&quot;connected using socket&quot;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile(&quot;rb&quot;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                    2003, &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (self.host, e)
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
&gt;               raise exc
E               django.db.utils.OperationalError: (2003, &quot;Can&apos;t connect to MySQL server on &apos;mysql.FullHouse.secoder.local&apos; ([Errno 8] nodename nor servname provided, or not known)&quot;)

../../../opt/anaconda3/lib/python3.8/site-packages/pymysql/connections.py:664: OperationalError</failure></testcase><testcase classname="tests.login_test.TestLogin" file="tests/login_test.py" line="185" name="test_is_registered" time="5.003"><failure message="django.db.utils.OperationalError: (2003, &quot;Can&apos;t connect to MySQL server on &apos;mysql.FullHouse.secoder.local&apos; ([Errno 8] nodename nor servname provided, or not known)&quot;)">self = &lt;pymysql.connections.Connection object at 0x7fb33e0379d0&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG:
                        print(&quot;connected using unix_socket&quot;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&quot;source_address&quot;] = (self.bind_address, 0)
                    while True:
                        try:
&gt;                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

../../../opt/anaconda3/lib/python3.8/site-packages/pymysql/connections.py:613: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;mysql.FullHouse.secoder.local&apos;, 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        err = None
&gt;       for res in getaddrinfo(host, port, 0, SOCK_STREAM):

../../../opt/anaconda3/lib/python3.8/socket.py:787: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = &apos;mysql.FullHouse.secoder.local&apos;, port = 3306, family = 0, type = &lt;SocketKind.SOCK_STREAM: 1&gt;, proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        &quot;&quot;&quot;Resolve host and port into list of address info entries.
    
        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as &apos;http&apos;, a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.
    
        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        &quot;&quot;&quot;
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
&gt;       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno 8] nodename nor servname provided, or not known

../../../opt/anaconda3/lib/python3.8/socket.py:918: gaierror

During handling of the above exception, another exception occurred:

self = &lt;django.db.backends.mysql.base.DatabaseWrapper object at 0x7fb33d1c1070&gt;

    @async_unsafe
    def ensure_connection(self):
        &quot;&quot;&quot;Guarantee that a connection to the database is established.&quot;&quot;&quot;
        if self.connection is None:
            with self.wrap_database_errors:
&gt;               self.connect()

../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/base/base.py:220: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (&lt;django.db.backends.mysql.base.DatabaseWrapper object at 0x7fb33d1c1070&gt;,), kwargs = {}
event_loop = &lt;_UnixSelectorEventLoop running=False closed=False debug=False&gt;

    @functools.wraps(func)
    def inner(*args, **kwargs):
        if not os.environ.get(&apos;DJANGO_ALLOW_ASYNC_UNSAFE&apos;):
            # Detect a running event loop in this thread.
            try:
                event_loop = asyncio.get_event_loop()
            except RuntimeError:
                pass
            else:
                if event_loop.is_running():
                    raise SynchronousOnlyOperation(message)
        # Pass onwards.
&gt;       return func(*args, **kwargs)

../../../opt/anaconda3/lib/python3.8/site-packages/django/utils/asyncio.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.db.backends.mysql.base.DatabaseWrapper object at 0x7fb33d1c1070&gt;

    @async_unsafe
    def connect(self):
        &quot;&quot;&quot;Connect to the database. Assume that the connection is closed.&quot;&quot;&quot;
        # Check for invalid configurations.
        self.check_settings()
        # In case the previous connection was closed while in an atomic block
        self.in_atomic_block = False
        self.savepoint_ids = []
        self.needs_rollback = False
        # Reset parameters defining when to close the connection
        max_age = self.settings_dict[&apos;CONN_MAX_AGE&apos;]
        self.close_at = None if max_age is None else time.monotonic() + max_age
        self.closed_in_transaction = False
        self.errors_occurred = False
        # Establish the connection
        conn_params = self.get_connection_params()
&gt;       self.connection = self.get_new_connection(conn_params)

../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/base/base.py:197: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (&lt;django.db.backends.mysql.base.DatabaseWrapper object at 0x7fb33d1c1070&gt;, {&apos;charset&apos;: &apos;utf8&apos;, &apos;client_flag&apos;: 2, &apos;conv... escape_float at 0x7fb33d1fc1f0&gt;, &lt;class &apos;str&apos;&gt;: &lt;function escape_str at 0x7fb33d1fc430&gt;, ...}, &apos;db&apos;: &apos;kuaishou&apos;, ...})
kwargs = {}, event_loop = &lt;_UnixSelectorEventLoop running=False closed=False debug=False&gt;

    @functools.wraps(func)
    def inner(*args, **kwargs):
        if not os.environ.get(&apos;DJANGO_ALLOW_ASYNC_UNSAFE&apos;):
            # Detect a running event loop in this thread.
            try:
                event_loop = asyncio.get_event_loop()
            except RuntimeError:
                pass
            else:
                if event_loop.is_running():
                    raise SynchronousOnlyOperation(message)
        # Pass onwards.
&gt;       return func(*args, **kwargs)

../../../opt/anaconda3/lib/python3.8/site-packages/django/utils/asyncio.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.db.backends.mysql.base.DatabaseWrapper object at 0x7fb33d1c1070&gt;
conn_params = {&apos;charset&apos;: &apos;utf8&apos;, &apos;client_flag&apos;: 2, &apos;conv&apos;: {&lt;class &apos;bool&apos;&gt;: &lt;function escape_bool at 0x7fb33d1fc0d0&gt;, &lt;class &apos;int&apos;&gt;...n escape_float at 0x7fb33d1fc1f0&gt;, &lt;class &apos;str&apos;&gt;: &lt;function escape_str at 0x7fb33d1fc430&gt;, ...}, &apos;db&apos;: &apos;kuaishou&apos;, ...}

    @async_unsafe
    def get_new_connection(self, conn_params):
&gt;       return Database.connect(**conn_params)

../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/mysql/base.py:233: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pymysql.connections.Connection object at 0x7fb33e0379d0&gt;

    def __init__(
        self,
        *,
        user=None,  # The first four arguments is based on DB-API 2.0 recommendation.
        password=&quot;&quot;,
        host=None,
        database=None,
        unix_socket=None,
        port=0,
        charset=&quot;&quot;,
        sql_mode=None,
        read_default_file=None,
        conv=None,
        use_unicode=True,
        client_flag=0,
        cursorclass=Cursor,
        init_command=None,
        connect_timeout=10,
        read_default_group=None,
        autocommit=False,
        local_infile=False,
        max_allowed_packet=16 * 1024 * 1024,
        defer_connect=False,
        auth_plugin_map=None,
        read_timeout=None,
        write_timeout=None,
        bind_address=None,
        binary_prefix=False,
        program_name=None,
        server_public_key=None,
        ssl=None,
        ssl_ca=None,
        ssl_cert=None,
        ssl_disabled=None,
        ssl_key=None,
        ssl_verify_cert=None,
        ssl_verify_identity=None,
        compress=None,  # not supported
        named_pipe=None,  # not supported
        passwd=None,  # deprecated
        db=None,  # deprecated
    ):
        if db is not None and database is None:
            # We will raise warining in 2022 or later.
            # See https://github.com/PyMySQL/PyMySQL/issues/939
            # warnings.warn(&quot;&apos;db&apos; is deprecated, use &apos;database&apos;&quot;, DeprecationWarning, 3)
            database = db
        if passwd is not None and not password:
            # We will raise warining in 2022 or later.
            # See https://github.com/PyMySQL/PyMySQL/issues/939
            # warnings.warn(
            #    &quot;&apos;passwd&apos; is deprecated, use &apos;password&apos;&quot;, DeprecationWarning, 3
            # )
            password = passwd
    
        if compress or named_pipe:
            raise NotImplementedError(
                &quot;compress and named_pipe arguments are not supported&quot;
            )
    
        self._local_infile = bool(local_infile)
        if self._local_infile:
            client_flag |= CLIENT.LOCAL_FILES
    
        if read_default_group and not read_default_file:
            if sys.platform.startswith(&quot;win&quot;):
                read_default_file = &quot;c:\\my.ini&quot;
            else:
                read_default_file = &quot;/etc/my.cnf&quot;
    
        if read_default_file:
            if not read_default_group:
                read_default_group = &quot;client&quot;
    
            cfg = Parser()
            cfg.read(os.path.expanduser(read_default_file))
    
            def _config(key, arg):
                if arg:
                    return arg
                try:
                    return cfg.get(read_default_group, key)
                except Exception:
                    return arg
    
            user = _config(&quot;user&quot;, user)
            password = _config(&quot;password&quot;, password)
            host = _config(&quot;host&quot;, host)
            database = _config(&quot;database&quot;, database)
            unix_socket = _config(&quot;socket&quot;, unix_socket)
            port = int(_config(&quot;port&quot;, port))
            bind_address = _config(&quot;bind-address&quot;, bind_address)
            charset = _config(&quot;default-character-set&quot;, charset)
            if not ssl:
                ssl = {}
            if isinstance(ssl, dict):
                for key in [&quot;ca&quot;, &quot;capath&quot;, &quot;cert&quot;, &quot;key&quot;, &quot;cipher&quot;]:
                    value = _config(&quot;ssl-&quot; + key, ssl.get(key))
                    if value:
                        ssl[key] = value
    
        self.ssl = False
        if not ssl_disabled:
            if ssl_ca or ssl_cert or ssl_key or ssl_verify_cert or ssl_verify_identity:
                ssl = {
                    &quot;ca&quot;: ssl_ca,
                    &quot;check_hostname&quot;: bool(ssl_verify_identity),
                    &quot;verify_mode&quot;: ssl_verify_cert
                    if ssl_verify_cert is not None
                    else False,
                }
                if ssl_cert is not None:
                    ssl[&quot;cert&quot;] = ssl_cert
                if ssl_key is not None:
                    ssl[&quot;key&quot;] = ssl_key
            if ssl:
                if not SSL_ENABLED:
                    raise NotImplementedError(&quot;ssl module not found&quot;)
                self.ssl = True
                client_flag |= CLIENT.SSL
                self.ctx = self._create_ssl_ctx(ssl)
    
        self.host = host or &quot;localhost&quot;
        self.port = port or 3306
        if type(self.port) is not int:
            raise ValueError(&quot;port should be of type int&quot;)
        self.user = user or DEFAULT_USER
        self.password = password or b&quot;&quot;
        if isinstance(self.password, str):
            self.password = self.password.encode(&quot;latin1&quot;)
        self.db = database
        self.unix_socket = unix_socket
        self.bind_address = bind_address
        if not (0 &lt; connect_timeout &lt;= 31536000):
            raise ValueError(&quot;connect_timeout should be &gt;0 and &lt;=31536000&quot;)
        self.connect_timeout = connect_timeout or None
        if read_timeout is not None and read_timeout &lt;= 0:
            raise ValueError(&quot;read_timeout should be &gt; 0&quot;)
        self._read_timeout = read_timeout
        if write_timeout is not None and write_timeout &lt;= 0:
            raise ValueError(&quot;write_timeout should be &gt; 0&quot;)
        self._write_timeout = write_timeout
    
        self.charset = charset or DEFAULT_CHARSET
        self.use_unicode = use_unicode
    
        self.encoding = charset_by_name(self.charset).encoding
    
        client_flag |= CLIENT.CAPABILITIES
        if self.db:
            client_flag |= CLIENT.CONNECT_WITH_DB
    
        self.client_flag = client_flag
    
        self.cursorclass = cursorclass
    
        self._result = None
        self._affected_rows = 0
        self.host_info = &quot;Not connected&quot;
    
        # specified autocommit mode. None means use server default.
        self.autocommit_mode = autocommit
    
        if conv is None:
            conv = converters.conversions
    
        # Need for MySQLdb compatibility.
        self.encoders = {k: v for (k, v) in conv.items() if type(k) is not int}
        self.decoders = {k: v for (k, v) in conv.items() if type(k) is int}
        self.sql_mode = sql_mode
        self.init_command = init_command
        self.max_allowed_packet = max_allowed_packet
        self._auth_plugin_map = auth_plugin_map or {}
        self._binary_prefix = binary_prefix
        self.server_public_key = server_public_key
    
        self._connect_attrs = {
            &quot;_client_name&quot;: &quot;pymysql&quot;,
            &quot;_pid&quot;: str(os.getpid()),
            &quot;_client_version&quot;: VERSION_STRING,
        }
    
        if program_name:
            self._connect_attrs[&quot;program_name&quot;] = program_name
    
        if defer_connect:
            self._sock = None
        else:
&gt;           self.connect()

../../../opt/anaconda3/lib/python3.8/site-packages/pymysql/connections.py:353: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pymysql.connections.Connection object at 0x7fb33e0379d0&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG:
                        print(&quot;connected using unix_socket&quot;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&quot;source_address&quot;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG:
                        print(&quot;connected using socket&quot;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile(&quot;rb&quot;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                    2003, &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (self.host, e)
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
&gt;               raise exc
E               pymysql.err.OperationalError: (2003, &quot;Can&apos;t connect to MySQL server on &apos;mysql.FullHouse.secoder.local&apos; ([Errno 8] nodename nor servname provided, or not known)&quot;)

../../../opt/anaconda3/lib/python3.8/site-packages/pymysql/connections.py:664: OperationalError

The above exception was the direct cause of the following exception:

self = &lt;tests.login_test.TestLogin testMethod=test_is_registered&gt;

    def setUp(self):
&gt;       brisa = User.objects.create(open_id=&quot;todayisagoodday&quot;,
                                    public_count=2,
                                    friend_count=0,
                                    private_count=0,
                                    all_count=2)

tests/login_test.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/manager.py:82: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/query.py:433: in create
    obj.save(force_insert=True, using=self.db)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/base.py:745: in save
    self.save_base(using=using, force_insert=force_insert,
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/base.py:782: in save_base
    updated = self._save_table(
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/base.py:887: in _save_table
    results = self._do_insert(cls._base_manager, using, fields, returning_fields, raw)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/base.py:924: in _do_insert
    return manager._insert(
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/manager.py:82: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/query.py:1204: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/sql/compiler.py:1390: in execute_sql
    with self.connection.cursor() as cursor:
../../../opt/anaconda3/lib/python3.8/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/base/base.py:260: in cursor
    return self._cursor()
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/base/base.py:236: in _cursor
    self.ensure_connection()
../../../opt/anaconda3/lib/python3.8/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/base/base.py:220: in ensure_connection
    self.connect()
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/utils.py:90: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/base/base.py:220: in ensure_connection
    self.connect()
../../../opt/anaconda3/lib/python3.8/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/base/base.py:197: in connect
    self.connection = self.get_new_connection(conn_params)
../../../opt/anaconda3/lib/python3.8/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/mysql/base.py:233: in get_new_connection
    return Database.connect(**conn_params)
../../../opt/anaconda3/lib/python3.8/site-packages/pymysql/connections.py:353: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pymysql.connections.Connection object at 0x7fb33e0379d0&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG:
                        print(&quot;connected using unix_socket&quot;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&quot;source_address&quot;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG:
                        print(&quot;connected using socket&quot;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile(&quot;rb&quot;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                    2003, &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (self.host, e)
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
&gt;               raise exc
E               django.db.utils.OperationalError: (2003, &quot;Can&apos;t connect to MySQL server on &apos;mysql.FullHouse.secoder.local&apos; ([Errno 8] nodename nor servname provided, or not known)&quot;)

../../../opt/anaconda3/lib/python3.8/site-packages/pymysql/connections.py:664: OperationalError</failure></testcase><testcase classname="tests.login_test.TestLogin" file="tests/login_test.py" line="144" name="test_update_registered_user" time="5.003"><failure message="django.db.utils.OperationalError: (2003, &quot;Can&apos;t connect to MySQL server on &apos;mysql.FullHouse.secoder.local&apos; ([Errno 8] nodename nor servname provided, or not known)&quot;)">self = &lt;pymysql.connections.Connection object at 0x7fb33e3bc8b0&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG:
                        print(&quot;connected using unix_socket&quot;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&quot;source_address&quot;] = (self.bind_address, 0)
                    while True:
                        try:
&gt;                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

../../../opt/anaconda3/lib/python3.8/site-packages/pymysql/connections.py:613: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;mysql.FullHouse.secoder.local&apos;, 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        err = None
&gt;       for res in getaddrinfo(host, port, 0, SOCK_STREAM):

../../../opt/anaconda3/lib/python3.8/socket.py:787: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = &apos;mysql.FullHouse.secoder.local&apos;, port = 3306, family = 0, type = &lt;SocketKind.SOCK_STREAM: 1&gt;, proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        &quot;&quot;&quot;Resolve host and port into list of address info entries.
    
        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as &apos;http&apos;, a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.
    
        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        &quot;&quot;&quot;
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
&gt;       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
E       socket.gaierror: [Errno 8] nodename nor servname provided, or not known

../../../opt/anaconda3/lib/python3.8/socket.py:918: gaierror

During handling of the above exception, another exception occurred:

self = &lt;django.db.backends.mysql.base.DatabaseWrapper object at 0x7fb33d1c1070&gt;

    @async_unsafe
    def ensure_connection(self):
        &quot;&quot;&quot;Guarantee that a connection to the database is established.&quot;&quot;&quot;
        if self.connection is None:
            with self.wrap_database_errors:
&gt;               self.connect()

../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/base/base.py:220: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (&lt;django.db.backends.mysql.base.DatabaseWrapper object at 0x7fb33d1c1070&gt;,), kwargs = {}
event_loop = &lt;_UnixSelectorEventLoop running=False closed=False debug=False&gt;

    @functools.wraps(func)
    def inner(*args, **kwargs):
        if not os.environ.get(&apos;DJANGO_ALLOW_ASYNC_UNSAFE&apos;):
            # Detect a running event loop in this thread.
            try:
                event_loop = asyncio.get_event_loop()
            except RuntimeError:
                pass
            else:
                if event_loop.is_running():
                    raise SynchronousOnlyOperation(message)
        # Pass onwards.
&gt;       return func(*args, **kwargs)

../../../opt/anaconda3/lib/python3.8/site-packages/django/utils/asyncio.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.db.backends.mysql.base.DatabaseWrapper object at 0x7fb33d1c1070&gt;

    @async_unsafe
    def connect(self):
        &quot;&quot;&quot;Connect to the database. Assume that the connection is closed.&quot;&quot;&quot;
        # Check for invalid configurations.
        self.check_settings()
        # In case the previous connection was closed while in an atomic block
        self.in_atomic_block = False
        self.savepoint_ids = []
        self.needs_rollback = False
        # Reset parameters defining when to close the connection
        max_age = self.settings_dict[&apos;CONN_MAX_AGE&apos;]
        self.close_at = None if max_age is None else time.monotonic() + max_age
        self.closed_in_transaction = False
        self.errors_occurred = False
        # Establish the connection
        conn_params = self.get_connection_params()
&gt;       self.connection = self.get_new_connection(conn_params)

../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/base/base.py:197: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (&lt;django.db.backends.mysql.base.DatabaseWrapper object at 0x7fb33d1c1070&gt;, {&apos;charset&apos;: &apos;utf8&apos;, &apos;client_flag&apos;: 2, &apos;conv... escape_float at 0x7fb33d1fc1f0&gt;, &lt;class &apos;str&apos;&gt;: &lt;function escape_str at 0x7fb33d1fc430&gt;, ...}, &apos;db&apos;: &apos;kuaishou&apos;, ...})
kwargs = {}, event_loop = &lt;_UnixSelectorEventLoop running=False closed=False debug=False&gt;

    @functools.wraps(func)
    def inner(*args, **kwargs):
        if not os.environ.get(&apos;DJANGO_ALLOW_ASYNC_UNSAFE&apos;):
            # Detect a running event loop in this thread.
            try:
                event_loop = asyncio.get_event_loop()
            except RuntimeError:
                pass
            else:
                if event_loop.is_running():
                    raise SynchronousOnlyOperation(message)
        # Pass onwards.
&gt;       return func(*args, **kwargs)

../../../opt/anaconda3/lib/python3.8/site-packages/django/utils/asyncio.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.db.backends.mysql.base.DatabaseWrapper object at 0x7fb33d1c1070&gt;
conn_params = {&apos;charset&apos;: &apos;utf8&apos;, &apos;client_flag&apos;: 2, &apos;conv&apos;: {&lt;class &apos;bool&apos;&gt;: &lt;function escape_bool at 0x7fb33d1fc0d0&gt;, &lt;class &apos;int&apos;&gt;...n escape_float at 0x7fb33d1fc1f0&gt;, &lt;class &apos;str&apos;&gt;: &lt;function escape_str at 0x7fb33d1fc430&gt;, ...}, &apos;db&apos;: &apos;kuaishou&apos;, ...}

    @async_unsafe
    def get_new_connection(self, conn_params):
&gt;       return Database.connect(**conn_params)

../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/mysql/base.py:233: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pymysql.connections.Connection object at 0x7fb33e3bc8b0&gt;

    def __init__(
        self,
        *,
        user=None,  # The first four arguments is based on DB-API 2.0 recommendation.
        password=&quot;&quot;,
        host=None,
        database=None,
        unix_socket=None,
        port=0,
        charset=&quot;&quot;,
        sql_mode=None,
        read_default_file=None,
        conv=None,
        use_unicode=True,
        client_flag=0,
        cursorclass=Cursor,
        init_command=None,
        connect_timeout=10,
        read_default_group=None,
        autocommit=False,
        local_infile=False,
        max_allowed_packet=16 * 1024 * 1024,
        defer_connect=False,
        auth_plugin_map=None,
        read_timeout=None,
        write_timeout=None,
        bind_address=None,
        binary_prefix=False,
        program_name=None,
        server_public_key=None,
        ssl=None,
        ssl_ca=None,
        ssl_cert=None,
        ssl_disabled=None,
        ssl_key=None,
        ssl_verify_cert=None,
        ssl_verify_identity=None,
        compress=None,  # not supported
        named_pipe=None,  # not supported
        passwd=None,  # deprecated
        db=None,  # deprecated
    ):
        if db is not None and database is None:
            # We will raise warining in 2022 or later.
            # See https://github.com/PyMySQL/PyMySQL/issues/939
            # warnings.warn(&quot;&apos;db&apos; is deprecated, use &apos;database&apos;&quot;, DeprecationWarning, 3)
            database = db
        if passwd is not None and not password:
            # We will raise warining in 2022 or later.
            # See https://github.com/PyMySQL/PyMySQL/issues/939
            # warnings.warn(
            #    &quot;&apos;passwd&apos; is deprecated, use &apos;password&apos;&quot;, DeprecationWarning, 3
            # )
            password = passwd
    
        if compress or named_pipe:
            raise NotImplementedError(
                &quot;compress and named_pipe arguments are not supported&quot;
            )
    
        self._local_infile = bool(local_infile)
        if self._local_infile:
            client_flag |= CLIENT.LOCAL_FILES
    
        if read_default_group and not read_default_file:
            if sys.platform.startswith(&quot;win&quot;):
                read_default_file = &quot;c:\\my.ini&quot;
            else:
                read_default_file = &quot;/etc/my.cnf&quot;
    
        if read_default_file:
            if not read_default_group:
                read_default_group = &quot;client&quot;
    
            cfg = Parser()
            cfg.read(os.path.expanduser(read_default_file))
    
            def _config(key, arg):
                if arg:
                    return arg
                try:
                    return cfg.get(read_default_group, key)
                except Exception:
                    return arg
    
            user = _config(&quot;user&quot;, user)
            password = _config(&quot;password&quot;, password)
            host = _config(&quot;host&quot;, host)
            database = _config(&quot;database&quot;, database)
            unix_socket = _config(&quot;socket&quot;, unix_socket)
            port = int(_config(&quot;port&quot;, port))
            bind_address = _config(&quot;bind-address&quot;, bind_address)
            charset = _config(&quot;default-character-set&quot;, charset)
            if not ssl:
                ssl = {}
            if isinstance(ssl, dict):
                for key in [&quot;ca&quot;, &quot;capath&quot;, &quot;cert&quot;, &quot;key&quot;, &quot;cipher&quot;]:
                    value = _config(&quot;ssl-&quot; + key, ssl.get(key))
                    if value:
                        ssl[key] = value
    
        self.ssl = False
        if not ssl_disabled:
            if ssl_ca or ssl_cert or ssl_key or ssl_verify_cert or ssl_verify_identity:
                ssl = {
                    &quot;ca&quot;: ssl_ca,
                    &quot;check_hostname&quot;: bool(ssl_verify_identity),
                    &quot;verify_mode&quot;: ssl_verify_cert
                    if ssl_verify_cert is not None
                    else False,
                }
                if ssl_cert is not None:
                    ssl[&quot;cert&quot;] = ssl_cert
                if ssl_key is not None:
                    ssl[&quot;key&quot;] = ssl_key
            if ssl:
                if not SSL_ENABLED:
                    raise NotImplementedError(&quot;ssl module not found&quot;)
                self.ssl = True
                client_flag |= CLIENT.SSL
                self.ctx = self._create_ssl_ctx(ssl)
    
        self.host = host or &quot;localhost&quot;
        self.port = port or 3306
        if type(self.port) is not int:
            raise ValueError(&quot;port should be of type int&quot;)
        self.user = user or DEFAULT_USER
        self.password = password or b&quot;&quot;
        if isinstance(self.password, str):
            self.password = self.password.encode(&quot;latin1&quot;)
        self.db = database
        self.unix_socket = unix_socket
        self.bind_address = bind_address
        if not (0 &lt; connect_timeout &lt;= 31536000):
            raise ValueError(&quot;connect_timeout should be &gt;0 and &lt;=31536000&quot;)
        self.connect_timeout = connect_timeout or None
        if read_timeout is not None and read_timeout &lt;= 0:
            raise ValueError(&quot;read_timeout should be &gt; 0&quot;)
        self._read_timeout = read_timeout
        if write_timeout is not None and write_timeout &lt;= 0:
            raise ValueError(&quot;write_timeout should be &gt; 0&quot;)
        self._write_timeout = write_timeout
    
        self.charset = charset or DEFAULT_CHARSET
        self.use_unicode = use_unicode
    
        self.encoding = charset_by_name(self.charset).encoding
    
        client_flag |= CLIENT.CAPABILITIES
        if self.db:
            client_flag |= CLIENT.CONNECT_WITH_DB
    
        self.client_flag = client_flag
    
        self.cursorclass = cursorclass
    
        self._result = None
        self._affected_rows = 0
        self.host_info = &quot;Not connected&quot;
    
        # specified autocommit mode. None means use server default.
        self.autocommit_mode = autocommit
    
        if conv is None:
            conv = converters.conversions
    
        # Need for MySQLdb compatibility.
        self.encoders = {k: v for (k, v) in conv.items() if type(k) is not int}
        self.decoders = {k: v for (k, v) in conv.items() if type(k) is int}
        self.sql_mode = sql_mode
        self.init_command = init_command
        self.max_allowed_packet = max_allowed_packet
        self._auth_plugin_map = auth_plugin_map or {}
        self._binary_prefix = binary_prefix
        self.server_public_key = server_public_key
    
        self._connect_attrs = {
            &quot;_client_name&quot;: &quot;pymysql&quot;,
            &quot;_pid&quot;: str(os.getpid()),
            &quot;_client_version&quot;: VERSION_STRING,
        }
    
        if program_name:
            self._connect_attrs[&quot;program_name&quot;] = program_name
    
        if defer_connect:
            self._sock = None
        else:
&gt;           self.connect()

../../../opt/anaconda3/lib/python3.8/site-packages/pymysql/connections.py:353: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pymysql.connections.Connection object at 0x7fb33e3bc8b0&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG:
                        print(&quot;connected using unix_socket&quot;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&quot;source_address&quot;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG:
                        print(&quot;connected using socket&quot;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile(&quot;rb&quot;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                    2003, &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (self.host, e)
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
&gt;               raise exc
E               pymysql.err.OperationalError: (2003, &quot;Can&apos;t connect to MySQL server on &apos;mysql.FullHouse.secoder.local&apos; ([Errno 8] nodename nor servname provided, or not known)&quot;)

../../../opt/anaconda3/lib/python3.8/site-packages/pymysql/connections.py:664: OperationalError

The above exception was the direct cause of the following exception:

self = &lt;tests.login_test.TestLogin testMethod=test_update_registered_user&gt;

    def setUp(self):
&gt;       brisa = User.objects.create(open_id=&quot;todayisagoodday&quot;,
                                    public_count=2,
                                    friend_count=0,
                                    private_count=0,
                                    all_count=2)

tests/login_test.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/manager.py:82: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/query.py:433: in create
    obj.save(force_insert=True, using=self.db)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/base.py:745: in save
    self.save_base(using=using, force_insert=force_insert,
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/base.py:782: in save_base
    updated = self._save_table(
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/base.py:887: in _save_table
    results = self._do_insert(cls._base_manager, using, fields, returning_fields, raw)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/base.py:924: in _do_insert
    return manager._insert(
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/manager.py:82: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/query.py:1204: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/models/sql/compiler.py:1390: in execute_sql
    with self.connection.cursor() as cursor:
../../../opt/anaconda3/lib/python3.8/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/base/base.py:260: in cursor
    return self._cursor()
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/base/base.py:236: in _cursor
    self.ensure_connection()
../../../opt/anaconda3/lib/python3.8/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/base/base.py:220: in ensure_connection
    self.connect()
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/utils.py:90: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/base/base.py:220: in ensure_connection
    self.connect()
../../../opt/anaconda3/lib/python3.8/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/base/base.py:197: in connect
    self.connection = self.get_new_connection(conn_params)
../../../opt/anaconda3/lib/python3.8/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../opt/anaconda3/lib/python3.8/site-packages/django/db/backends/mysql/base.py:233: in get_new_connection
    return Database.connect(**conn_params)
../../../opt/anaconda3/lib/python3.8/site-packages/pymysql/connections.py:353: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pymysql.connections.Connection object at 0x7fb33e3bc8b0&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG:
                        print(&quot;connected using unix_socket&quot;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&quot;source_address&quot;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG:
                        print(&quot;connected using socket&quot;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile(&quot;rb&quot;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                    2003, &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (self.host, e)
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
&gt;               raise exc
E               django.db.utils.OperationalError: (2003, &quot;Can&apos;t connect to MySQL server on &apos;mysql.FullHouse.secoder.local&apos; ([Errno 8] nodename nor servname provided, or not known)&quot;)

../../../opt/anaconda3/lib/python3.8/site-packages/pymysql/connections.py:664: OperationalError</failure></testcase></testsuite></testsuites>